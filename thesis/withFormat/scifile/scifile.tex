
\documentclass[12pt]{article}

\usepackage{theorem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{scicite}
\usepackage{algorithmicx}
\usepackage{algorithm}% http://ctan.org/pkg/algorithms
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx
\usepackage{xcolor}
\newtheorem{theorem}{Theorem}

\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{proof}{\textit{Proof}}
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\usepackage{times}
\topmargin 0.0cm
\oddsidemargin 0.2cm
\textwidth 16cm 
\textheight 21cm
\footskip 1.0cm


%The next command sets up an environment for the abstract to your paper.

\newenvironment{sciabstract}{%
\begin{quote} \bf}
{\end{quote}}


% If your reference list includes text notes as well as references,
% include the following line; otherwise, comment it out.

\renewcommand\refname{References and Notes}

% The following lines set up an environment for the last note in the
% reference list, which commonly includes acknowledgments of funding,
% help, etc.  It's intended for users of BibTeX or the {thebibliography}
% environment.  Users who are hand-coding their references at the end
% using a list environment such as {enumerate} can simply add another
% item at the end, and it will be numbered automatically.

\newcounter{lastnote}
\newenvironment{scilastnote}{%
\setcounter{lastnote}{\value{enumiv}}%
\addtocounter{lastnote}{+1}%
\begin{list}%
{\arabic{lastnote}.}
{\setlength{\leftmargin}{.22in}}
{\setlength{\labelsep}{.5em}}}
{\end{list}}


% Include your paper's title here

\title{An Algorithm for Reachability Problem of One-Counter Automata}


% Place the author information here.  Please hand-code the contact
% information and notecalls; do *not* use \footnote commands.  Let the
% author contact information appear immediately below the author names
% as shown.  We would also prefer that you don't change the type-size
% settings shown here.

\author
{XXXX
}

\date{}



%%%%%%%%%%%%%%%%% END OF PREAMBLE %%%%%%%%%%%%%%%%



\begin{document} 

% Double-space the manuscript.

\baselineskip24pt

% Make the title.

\maketitle 



% Place your abstract within the special {sciabstract} environment.

\begin{sciabstract}
TODO: Add abstract here.
\end{sciabstract}

\section{Introduction}

\section{Premilinaries}
\subsection{One-Counter Automata}

\begin{definition}[Counter Automata]
A $k$-counter automaton $\mathcal{A}$ is a tuple $\mathcal{A} = (Q, \Lambda, q_0, F, \Delta, \lambda, \epsilon)$ where
\begin{itemize}
\item $Q$ is a finite set of states,
\item $\Lambda$ is a finite set of labels,
\item $q_0\in Q$ is the initial state,
\item $F\subseteq Q$ is the set of final states,
\item $\Delta\subseteq Q\times Q$ is the transition relation,
\item $\lambda:Q\rightarrow 2^\Lambda$ is the state labelling function, and
\item $\epsilon:\Delta\rightarrow \text{Op}$ is a transition labelling function where $\text{Op} = \{\text{add}_i(z) : i\in [k], z\in \mathbb{Z}\} \cup \{\text{zero}_i:i\in [k]\}$ is a set of operations.
\end{itemize}

\end{definition}
\begin{definition}[One-Counter Automata]
An 


\end{definition}
\section{Algorithm}











%%%%%%%%%%%%%%%%%%%DRAFT BELOW%%%%%%%%%%%%%%%%%%%%%



According to \cite{DBLP:conf/icalp/ChistikovH17}, which gave a theoretical proof of the decidability and NP-lower and -upper bound for the reachability problem of one-counter automata. Given a one-counter automata $\mathcal{A}$ and its corresponding transition system $T(\mathcal{A})$ defined in \cite{DBLP:conf/icalp/ChistikovH17}. The reachability problem of one-counter auotmata can be stated as follows.

\paragraph{Reachability Problem of One-Counter Automata}

\paragraph{INPUT:} An one-coutner automata $\mathcal{A}$ and configurations $C, C'\in C(\mathcal{A})$, where $C(\mathcal{A}) = Q \times \mathbb{N}$.
\paragraph{OUTPUT:} Does $C \rightarrow^*_\mathcal{A} C'$?


More generally, we would like to use two variables to represent the counter values of the initial configuration and the ending configuration. Then we can convert the general problem into a QFPA(Quantifier-Free Presburger Arithmetic) Formula, such that the ending configuration is reachable from the initial configuration iff the QFPA formula is satisfiable.

\paragraph{General Reachability Problem of One-Counter Automata}

\paragraph{INPUT:} An one-coutner automata $\mathcal{A}$ and configurations $C, C'\in C(\mathcal{A})$, where $C(\mathcal{A}) = Q \times Var$ and $Var$ is the set of variables in the scope of natural number.

\paragraph{OUTPUT:} A QFPA formula $\phi$ that is satisfiable iff $C \rightarrow^*_\mathcal{A} C'$.\\

Due to the counter value and the possible infinity of the configurations of one-counter automata, finding a path in $T(\mathcal{A})$ is not realistic because it may cause exponential blow up \cite{DBLP:conf/icalp/ChistikovH17}. Thus we turn to consider the flow $f: E \rightarrow \mathbb{N}$ which assigns each edge in the automata a natural number. We call a flow \textit{path flow } if the assignment of the number exactly corresponds to the number of a path $\pi$ go through the edge in the automata. 

The following lemma gives neccessary conditions for a flow to be a path flow. The original proof of the lemma in \cite{DBLP:conf/icalp/ChistikovH17} is not complete.



%$\mathcal{A} = (Q, c, q_0, F, \Delta, \lambda, \epsilon)$ where $Q$ is the finite set of control locations, $c \ge 0 $ the counter value, $q_0$ the initial state, $F\subseteq Q$ the finite set of final locations and  
\begin{lemma}[Lemma 4.1.6 in \cite{DBLP:conf/icalp/ChistikovH17}]  A flow $f$ is a \textit{s-t} path flow iff $f$ satisfies the following conditions:
\begin{itemize}
\item If s = t then
\begin{enumerate}
\item $\Sigma_{w\in out(v)} f(v,w) = \Sigma_{w\in in(v)} f(w,v)$ for all v
\item $F(f)$ is a s-t support


\end{enumerate}


\item If s $\ne$ t then
\begin{enumerate}
\item $\Sigma_{w\in out(v)} f(v,w) = \Sigma_{w\in out(v)} f(w,v)$ for all $v\in V-\{s,t\}$

$\Sigma_{w\in out(s)} f(s,w) = \Sigma_{w\in out(s)} f(w,s) + 1$

$\Sigma_{w\in out(t)} = \Sigma_{w\in out(t)} f(w,t) - 1$


\item F(f) is connected.
\end{enumerate}

\end{itemize}



\end{lemma}


\begin{proof} Prove by induction on $n  = \Sigma_{e\in E} f(e)$\\
\begin{itemize}
\item $\Rightarrow$：
 By definition direction of path flow the proof is obvious.

\item $\Leftarrow$：
\begin{enumerate}
\item $s = t, F(f) is connected$, we have the conclusion that $f$ is a s-t path flow.

\begin{itemize}
\item case 1 : there is a self loop from $s$ to $s$.

\item case 2 : there is no self loop from $s$ to $s$. In this case we delete an edge from $v$ to $s$ such that $v \neq s$.

\begin{itemize}
\item subcase 2.1 the resulting graph is still connectedl let the new flow be $f'$. By the induction hypothesis $f'$ is a path flow from $s$ to $v$.

\item subcase 2.2 the resulting graph is not connected, in this case , there are exactly two connected components such in the resulting graph, we call them $C_1$ and $C_2$ and assume they contain $s$ and $v$ respectively.
\begin{itemize}
\item sub-subcase 2.2.1:
$C_2$ contains no edges.

\item sub-subcase 2.2.2:
$C_1$ and $C_2$ both contain at least one edge.

\end{itemize}
\end{itemize}
\end{itemize}

\item $s \ne t$ is the same idea, we omit the proof here.

\end{enumerate}
\end{itemize}


\end{proof}

By lemma 4.1.14 in \cite{DBLP:conf/icalp/ChistikovH17}, the problem whether $(q',n')$ is reachable from $(q,n)$ can be solve by enumerate all the type-1, type-3, and type-2 reachability and guess nondeterministically the possible path between them. We now present the algorithm in detail.


\begin{definition}[Reachability Certificate]
Defined the same as in \cite{DBLP:conf/icalp/ChistikovH17}
\end{definition}

By the definition of type-3 reachability certificate which require the positive cycle template. We put positive cycle template on the level of SCC of the weighted graph.


\begin{definition}[Weighted Graph]
Let $\mathcal{A}$ be an one-counter automaton, the \text{weighted graph} of $\mathcal{A}$ is $G = (V,E,\mu)$ where $V$ is a finite set of vertices according to the states of $\mathcal{A}$, $E\subseteq V\times V$ is a finite set of edges correspond to the edges of $\mathcal{A}$ and $\mu : E\rightarrow \mathbb{Z}$ is weight function correspond to the changes of the counter value of $\mathcal{A}$.
\end{definition}

We call $G' = (V', E', \mu')$ a \textit{subgraph} of a weighted graph $G = (V, E, \mu)$ if $V'\subseteq V$, $E'\subseteq E$ and $\mu' = \mu$.

We call $G^{op} = (V, E^{op}, \mu^{op})$ the \textit{skew transpose} of the graph.

\begin{definition}[Strongly Connected Component(SCC)]
A strongly connected component of a weighted graph $G$ is a subgraph $G' = (V', E', \mu)$ of $G$ and for $\forall v, v'\in V'$ and $v \ne v'$, there exist a path $\pi$ from $v$ to $v'$ and a path $\pi'$ from $v'$ to $v$.


\end{definition}

We have to add some  structure on an SCC to make the algorithm works. We do some classification on thetype of vertices in an SCC:

Given an SCC $G' = (V', E', \mu)$ which is the subgraph of a weighted graph $G = (V, E, \mu)$, we call a vertice $v'\in V'$ 

\begin{itemize}
\item an \textit{in-port vertex} if there exists $u \in V \wedge u \notin V'$ such that $(u,v) \in E$,
\item an \textit{out-port vertex} if there exists $u \in V \wedge u \notin V'$ such that $(v,u) \in E$,
\item and an \textit{internal vertex} otherwise.
\end{itemize}


\begin{definition}[Drop-Weight Table(DWT)]

Given a graph $G = (V, E, \mu)$ , we define its drop-weight table $DWT_{G}$ and simply use a tuple $DWT_{G}(v_1, v_2, l, P)$ to represent a entry of the table, where

\begin{itemize}
\item $v_1\in V$ is the starting node of  paths and $v_2\in V$ is the ending node of paths.

\item $l\in \mathbb{N}$ denote the maximum length of paths.

\item $P = \{(d,w)\mid w\in \mathbb{Z}, d\in \mathbb{Z}\}$ is a set remembering all the  drop-weight pairs.

\end{itemize}



Given a integer $n$, we use $DWT_{G}^n$ to denote a drop-weight table of $G$ that the length of paths we consider is at most $n$.
\end{definition}


With the definition of drop-weight table, we now need a algorithm to compute a table.

\begin{algorithm}
	\caption{Compute DWT}
	\begin{algorithmic}
		
		\State \Function{ComputeDWT}{$G$, $n$}			
		\State \textbf{Input:} A graph $G = (V,E,\mu)$ and an integer $n\in \mathbb{N}$
		\State \textbf{Output:} A DWT table $DWT_G^n$
		\State \Comment Initialize the table by the edges of the graph.
		\ForEach{$v\in V$}
			\ForEach{$(v,w)\in E$}
				\State For entry $DWT_G^n(v,w,1,P)$
				\State construct $(d,w)$ where
				\State $d = min(0, \mu(v,w))$, $w = \mu(v,w)$
				\State $P = P \cup \{(d,w)\}$
			\EndFor
		\EndFor
		
		\State
		
		\For{$i := 2$ to $n$}
			\For{$len:=1$ to $i-1$}
				\State $preLen := len$
				\State $sufLen := i - preLen$	
				\State $P_i := \bigcup_{DWT_G^n(s,t,i-1,P_k)} P_k$		
				\ForEach{$s\in V$}
					\ForEach{$t\in V$}
						\ForEach{$DWT_G^n(s, m, preLen, P_1)$}
							\ForEach{$DWT_G^n(m, t, sufLen, P_2)$}
							\State Let $(d_1, w_1)\in P_1$ and $(d_2, w_2)\in P_2$
							\State Construct $(d',w')$ from all possible tuple pairs:
							\State $d' := min(d_1, w_1+d_2)$
							\State $w' := w_1 + w_2$
							\State $P_i := P_i \cup \{(d',w')\}$							
							\EndFor
						\EndFor
						\State Add $(s,t,i,P_i)$ to the table.
					\EndFor
				\EndFor
			\EndFor
		\EndFor
		\EndFunction

	\end{algorithmic}
\end{algorithm}

The basic idea of the algorithm is that we first put all the edge information into the table, then for paths length $l$ larger than 1 we split the path into a prefix and a suffix  whose lengths are both smaller than $l$. Since we have already compute the table for paths that have a length smaller than $l$. We can use the result to acquire the result we need.\\



In order to get a path $\Pi= \pi_1\cdot \pi_2 \cdot \pi_3$ from $s$ to $t$ in   $\mathcal{A}$ corresponding to a run in $T(\mathcal{A})$. Algorithm needs to guess the start node $v_1$ and end node $v_2$ of $\pi_2$. By lemma 4.1.17, if $|\pi_2| > 0$ there should be a  positive cycle template at $v_1$ and a positive cycle template. Intuitively, a positive cycle template gives a overlook on the possible positive cycles in a SCC. That means if there is a simple positive cycle in an SCC, all other node can find a path to a point on that cycle and by circling the simple positive cycle many times. Then we can get a positive cycle on another point.
% TODO: the name I did not remember

In the algorithm we first convert the one-counter automaton into weighted graph and then shrink the graph into a abstract graph defined on SCC. Now we define the shrinked weighted graph.

\begin{definition}[Shrinked Weighted Graph]
Given a weighted graph $G = (V, E, \mu)$ we defined its corresponding shrinked weighted graph $SWG = (SCC(V), E', \mu')$, where
\begin{itemize}
\item $SCC(V) \subseteq V\times \mathbb{Z}^+$ is the set of all the SCCs and vertices in the same SCC have the same integer value.

\item $E'\subseteq SCC(V) \times SCC(V)$ is a finite set of transitions between the SCCs. We also require for any $v,v'\in V$ and $a,b \in \mathbb{Z}^+$, if $((v,a), (v'b)) \in E'$ then $a \ne b$

\item $\mu': E' \rightarrow \mathbb{Z}$ is the weight function that assign each edge a weight. The value remain the same as $\mu$ in $G$.
\end{itemize}

\end{definition}

%TODO more things internal inport outport
By the definition of SWG, it is obvious that it is a direct acycly graph. Now we need an algorithm to convert a weighted graph into a SWG by using Tarjan's algorithm [Add reference] to find the SCCs in a weighted graph.


\begin{algorithm}
	\caption{WG to SWG}
	\begin{algorithmic}[1]
	\State $SCCIndex := 1$
		\Function{WG2SWG}{$G$}
		
		\State\textbf{Input:} A weighted graph $G = (V,E,\mu)$
		\State\textbf{Output:} A shrinked weighted graph $SWG = (SCC(V), E', \mu')$	
		\State 
		\State $index$ := 1
		
		\State $S$ := empty stack
		\State Initialize  an empty shrinked weighted graph $G'$: 
		\State $SCC(V) := V\times {0}, E:=E, \mu' := \mu$
			
		\State  
		\ForEach {$(v,mark)\in SCC(V)$}
			\If{mark == 0}
				\State \Call{StrongConnect}{$(v,mark)$}
			\EndIf
		\EndFor
		\State\Return $SWG$
		\EndFunction
		
		\State
		\Function{StrongConnect}{$(v, mark)$}
			\State $v.$index := $index$
			\State $v$.lowlink := $index$
			\State $index$ := $index$ + 1
			\State $S$.push($v$)
			\State $v$.onStack := \textbf{true}
			\State			
			\State \Comment Consider successors of $v$
			\ForEach{$(v,w)\in E$}
				\If{$w.$index == 0}
					\State\Call{StrongConnect}{$w$}
					\State $v$.lowlink := $min(v$.lowlink$, w$.lowlink$ )$ 
				\ElsIf{$w$.onStack}
					\State $v$.lowlink := $min(v$.lowlink$, w. $index$)$ 
				\EndIf
			\EndFor
			\State
			\If{$v$.lowlink == $v.$index}
				\Repeat
					\State $w := S.pop()$					
					\State $w$.onStack $:= $ \textbf{false}
					\State $(w, mark) := (w, SCCIndex)$
					\State \Comment Add $w$ to current strongly connected component 
				
				
				\Until
				$w == v$
				\State $SCCIndex := SCCIndex + 1$ 
				\State\Comment Output the current strongly connected component
			\EndIf
		\EndFunction
	\end{algorithmic}

\end{algorithm}
 
Now by executing algorithm 2 we preprocess a given WG into a SWG.


\begin{definition}[Abstract Shrinked Weighted Graph]
	Given an $SWG = (SCC(V), E', \mu') $, we define its corresponding abstract shrinked weighted graph $ASWG = (S, E'', T, \mu', \eta)$ where 
\begin{itemize}
\item $S$ is a finite set of abstract state. A element  $s\in S$ represents an SCC in $SWG$.
\item $\eta: S\rightarrow SCC(V)$ is a function that maps a state in $S$ to its corresponding SCC.
\item $E'' \subseteq E'$ is a set of detailed edges of the form $((v_1,a), (v_2, b))$ where $(v_1, a), (v_2, b)\in SCC(V)$ and $a \ne b$,
\item $T\subseteq S \times S$ is a finite set of abstract edges. Given $s_1, s_2\in S$ and $(s_1, s_2)\in T$ iff there exists a edge $((v_1,t_1), (v_2, t_2))\in E''$ such that $t_1 = \eta(s_1)$ and $t_2 = \eta(s_2)$. 
\item $\sigma: S\rightarrow \{\{+\}, \{-\}, \{+,-\}, \{0\}\}$ is a function denoting whether there is a positive cycle($\{+\}$), negative cycle($\{-\}$), both($\{+,-\}$), or none($\{0\}$).

 
\end{itemize}
\end{definition}

We call the path $\tau: s_1\cdots s_n$ on an ASWG a $abstract $ $path$ where $s_i\in S$ and $(s_i, s_{i+1})\in T$

Given a weighted graph $(V,E,\mu)$ and its corresponding ASWG $(S<E'',T,\mu,\eta)$. We now define the operator $f_{SCC}: V\rightarrow S$ that maps a vertice to the SCC contains it. 

Algorithm 3 converts an SWG to an ASWG.

The idea of the algorithm goes as follows. Given an one-counter automaton we first convert it into a weighted graph[Hasse]. Then use algorithm 2 and algorithm 3 we get corresponding SWG and ASWG. Then we need to finish the $\sigma$ function in ASWG. The idea is using the algorithm 1 to compute the DWT of the SCCs and detect whether there is a positive, negative cycle in SCC. Here is the algorithm.


\begin{algorithm}
	\caption{SWG to ASWG}
	\begin{algorithmic}
		\State \Function{SWG2ASWG}{$SWG$}
		\State \textbf{Input: }$SWG = (SCC(V), E', \mu')$
		\State \textbf{Output: }$ASWG = (S, E'',T, \mu', \eta, \sigma)$
		\State 		
		\State $SCCNum := 0$	
		\ForEach{$(v,n)\in SCC(V)$}		
			\If{$n > SCCNum$}
				\State $SCCNum := n$
				\Comment Find the number of the SCCs in $SWG$.
			\EndIf
		\EndFor
		\State\textit{Initialize ASWG:} 
		\State $S := \{s_i\mid i\in [1,\ldots, SCCNum]\}$
		\State $E'', T := \emptyset$
		
		
		\ForEach{$((v_1, n_1),(v_2, n_2)\in E')$}
			\If{$n_1 \ne n_2$}
				\State \textit{Add }$(v_1, n_1),(v_2, n_2)$ \textit{to }$E''$.
				\If{$(s_{n_1}, s_{n_2})\notin T$}
					\State $T := T \cup \{(s_{n_1}, s_{n_2})\}$
				\EndIf
				
			\EndIf
		\EndFor
		\State 
		\ForEach{$s\in S$}
			\State $\sigma(s) :=$ \Call{TestCycle}{S}
		\EndFor
		\EndFunction
	\end{algorithmic}

\end{algorithm}


\begin{algorithm}
	\caption{Compute $\sigma$ in $ASWG$}

	\begin{algorithmic}
	\State \Function{TestCycle}{$SCC$}
		\State \textbf{Input: } $SCC = (V', E', \mu)$
		\State \textbf{Output: } $o \in \{\{+\}, \{-\}, \{+,-\}, \{0\}\}$.
		\State $DWT :=$ \Call{ComputeDWT}{$SCC,n$}
		\ForEach{$v\in V'$}
			\ForEach{$(v,v,n,P)\in DWT_{SCC}^n$}
				\ForEach{$(d,w)\in P$}
					\If{$w > 0$}
						\State $isPos :=$ \textbf{true}
					\ElsIf{$w < 0$}
						\State $isNeg :=$ \textbf{true}
					\EndIf
				\EndFor
			\EndFor
		
		\EndFor
		\State
		\If{$isPos \wedge isNeg$}
			\State\Return $\{+,-\}$
		\ElsIf{$isPos$}
			\State\Return $\{+\}$
		\ElsIf{$isNeg$}
			\State\Return $\{-\}$
		\Else
			\State\Return $\{0\}$
		\EndIf
	\EndFunction
	\end{algorithmic}

\end{algorithm}


\
By \cite{DBLP:conf/icalp/ChistikovH17} the correctness of deciding whether an SCC contains a positive cycle template is given by the following lemma.


\begin{lemma}
Given a strongly connected component $SCC = (V', E', \mu)$. There is a simple positive cycle in the $SCC$ iff for any $v\in V'$ there is a positive $v$-cycle template respect to an $n\in \mathbb{N}$.


\end{lemma}

\begin{proof}
\begin{itemize}
\item $\Leftarrow$: By the definition of $v$-cycle template this direction is obvious.                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
\item $\Rightarrow$:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
By the definition of $v$-cycle template in \cite{DBLP:conf/icalp/ChistikovH17} and the definition of the strongly connected component in this paper. Assume there is a positive cycle $\pi_+$ in the SCC, there exists a path from $v$ to any point one the $v$-cycle $\pi_+$. Here we only take a $p\in V'$ on $\pi_+$ and a v-p path $\pi_{v\text{-}p}$. Let $n = min(drop(\pi_+) + weight(\pi_{v\text{-}p}), drop(\pi_{v\text{-}p}))$. Then we have a positive $v$-cycle template $\pi = p_1\cdot p_2 \cdot p_3$ respect to $n$ where $p_1 = \pi_{v\text{-}p}$ and $p_2 = \pi_+$.

\end{itemize}
\end{proof}


After computing $\sigma$ in $ASWG = (S, E'', T, \mu', \eta, \sigma)$ there are four kinds of situations to be considered:
\begin{itemize}

\item\textbf{Situation 1:} There exists $s_1, s_2\in S$ (possibly $s_1 = s_2$) such that $+ \in \sigma(s_1)$ and $-\in \sigma(s_2)$
\item\textbf{Situation 2:}  For any $s\in S$,  $\sigma(s) = \{+\}$ or $\sigma(s) = \{0\}$
\item\textbf{Situation 3:} For any $s\in S$,  $\sigma(s) = \{-\}$ or $\sigma(s) = \{0\}$
\item \textbf{Situation 4:} For any $s\in S$,  $\sigma(s) = \{0\}$.
\end{itemize}




Due to the requirement that a type-3 reachability certificate require a positive cycle template and a negative cycle, we only need to find type-3 reachability certificate in \textbf{Situation 1}.


How to find all the possible path that may cause a reachability certificate. The diffcult problem is how to settle all the nondeterminism in the algorithm. Recall the definition of strongly connected componenet and its internal, inport and outport vertices before, we will use them to analyse how to generate a QFPA formula for reachability in the different situations above.



%TODO negative cycle template definition
Assume the reachability problem ask given an-counter automaton $\mathcal{A}$ and configurations $(s,n)$ an $(t,n')$, whether there is a run $(s,n)\rightarrow ^* (t, n')$

Firstly convert the one-counter automaton to a weighted graph $G = (V,E,\mu)$, an SWG $G' = (SCC(V), E', \mu')$ and an ASWG $G'' = (S,E'',T,\mu',\eta)$.

Let $m = f_{SCC}(s)\in S, n = f_{SCC}(t)\in S$.

\begin{itemize}
\item \textbf{Situation 1:}

Basic idea: Enumerate all the possible tuples $(p, q)$ where $p, q\in S$, $+ \in \sigma(p) $ and $- \in \sigma(q)$.

We first do DFS with a depth bound $|S|$ to find all the abstract path $\tau_1: m\cdots p$ where $+ \in \sigma(p)$ and put these abstract path into set $P_1$.

Likewise, do the same thing in $G''^{op}$ and find all the abstract path $\tau^{op}_3: n\cdots q$ where $-\in \sigma(q)$. convert $\tau^{op}_3$ to $\tau_3$ and put all these abstract paths into set $P_3$.

Then,  we need to find whether there is a abstract path between $p$ and $q$, the idea is also finding path by DFS. For  pair $(p,q)$, put all the abstract path $\tau_2 = p\cdots q$ into a set $P^{(p,q)}_2$.

With set $P_1^p, P^{(p,q)}_3, P_2^q$ where $p,q\in S$ we can now generate an abstract path that can be use to construct the reachability certificate by choosing abstract paths from $P_1^p, P_3^{(p,q)}, P_2^q$ and concatenante them. We summarize the process above in algorithm 4.

\begin{algorithm}
	\caption{Find Type-3 Abstract Paths}
	\begin{algorithmic}
		\State \Function{FindType3}{$WG$, $s$, $t$}
		\State\textbf{Input:} A weighted graph $WG$, starting vertex $s$ and ending vertex $t$.
		\State\textbf{Output:} An set of lists $\{[P_1^p, P_3^{(p,q)}, P_2^q]\}_{(p,q)}$ where $p,q$ are states in corresponding $ASWG$
		\State $SWG$ := \Call{WG2SWG}{$WG$}
		\State $ASWG$ := \Call{SWG2ASWG}{$SWG$}
		
		\State $PosSet$ := $\{s\mid s\in ASWG.S, +\in ASWG.\sigma(s)\}$
		\State $NegSet$ := $\{s\mid s\in ASWG.S, -\in ASWG.\sigma(s)\}$
		\State $list$ := []
		\ForEach{$p\in PosSet$}
			\State $P_1^p$ := \Call{DfsFindAbsPath}{$ASWG$, $s$, $p$}
			\ForEach{$q\in NegSet$}
				\State $P_3^{(p,q)}$ := \Call{DfsFindAbsPath}{$ASWG$, $p$, $q$}
				\State $P_2^{q}$ := \Call{DfsFindAbsPath}{$ASWG$, $q$, $t$}
				\State $list$ := $list \cup \{[P_1^p, P_3^{(p,q)}, P_2^q]\}$
			\EndFor
		\EndFor
		\State \Return $list$
		\EndFunction
	
		
		%\State \Function{FindType1}{$WG, s, v$}		
		%	\State \textbf{Input:} A weighted graph $WG$, starting vertex $s$ and a vertex $v$.
		%	\State \textbf{Output:} A set of abstract paths in $ASWG$.
			
		%	\State
		%	\State $SWG$ := \Call{WG2SWG}{$WG$}
		%	\State $ASWG$ := \Call{SWG2ASWG}{$SWG$}
		%	\State Let $s_a$ and  $t_a$ be the state of $ASWG$   corresponding to $s$ and $v$
		%	\State $paths$ := \Call{DfsFindAbsPath}{$ASWG, s_a, t_a$}%
		%	\State \Return $paths$
		%
		%\EndFunction
		\State \Function{DfsFindAbsPath}{$ASWG$, $p_1$, $p_2$}
			\State \textbf{Input: }An $ASWG = (S,E'',T,\mu,\eta,\sigma)$, starting state $p_1$ and target state $p_2$.
			\State \textbf{Output: }a set of all the abstract paths $P$.
			\State $current$ := $p_1$
			\State $S$ := empty stack
			\State $S.push(p_1)$
			\While{$\exists(current, u)\in ASWG.T$ not visited\textbf{ and }$current \neq $ \textbf{null}}
				\State $S.push(u)$
				\State $current$ := $u$
				\If{$current == p_2$}
					\State Output the stack as a path to $P$
					\State $S.pop()$
					\State $current$ := $S.top()$
				\EndIf				
				\If{all $(current, u)\in ASWG.T$ are visited}
					\State $S.pop()$
					\State $current$ := $S.top()$
				\EndIf
			\EndWhile
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Now we have solved the nondeterminism of choosing possible $(p,q)$, the nodeterminism of choosing the concrete path between SCCs and the possible paths in an SCC from inports to outports. 

%TODO a lemma states the correctness of the algorithm 


By the definition of type-1 reachability certificate in \cite{DBLP:conf/icalp/ChistikovH17}, which requries a support without positive cycles, weight and the correct sum of the weight along the path. It is obvious that on a path the concrete edges between SCCs will at most be visited once. Hence we can split the type-1 reachability certificate into SCCs the type-1 abstract path visited.


Given a SCC $G' = (V', E', \mu)$ by the definitions above, there is a set of inports $V_{in}$ and a set of outports $V_{out}$.

Let $\{(v_{i}, v_{o})\mid v_i\in V_{in}, v_o \in V_{out}\}$  be all the inport-outport tuples. Due to the storng connectivity of SCC, there exists at least one path in $G'$ starting from $v_i$ and ending at $v_o$. Since for one tuple there are often many reachable paths in the graph, we would like to introduce a dynamic programming techniques which saves time we computing the drop and weight of a path whose length is less than a integer value. We define a table that store the intermediate result of the computation.



Having a DWT it is much more convienient to generate the QFPA formula that related to the properties of path flows and paths. We take the generation of the positive cycle template as an example. 

By the definition of positive cycle template and our assumption that positive cycle appears in an SCC with a $+$ tag. In that SCC, assume the inport is $v_1$ and outport is $t'$. To find a vertex $v$ with a simple positive cycle we only need to check $DWT_{SCC}^n(v,v,n,P_2)$ where $\exists (d_2,w_2)\in P \wedge w > 0 $. A path from inport $v_1$ to $v$ is also needed, hence we check $DWT_G^n(v_1, v, n, P_1)$. Then a positive cycle template can be formed as 
\begin{center}
$\exists x\bigvee_{(d_1,w_1)\in P_1\, (d_2,w_2)\in P} x+d_1 \ge 0 \wedge x+w_1+d_2 \ge 0 \wedge w_2>0$
\end{center}

where $x$ is the initial counter value and we treat it as a variable.

As shown by the example above, it is much easier to write the QFPA formula for the existence of type-2 reachability certificate $\pi_2$.

Before explaining the idea of the algorithm for type-1 reachability certificate, we first propose a lemma.
\begin{lemma}
Given an $SCC = (V', E', \mu)$ and an inport $v_i\in V'$ and a outport $v_o \in V'$. Assume $|V'| \ge 2$ and there is a path $\pi = v_i\cdots v_o$ that contains cycles and there is no positive cycle along the path. If $|\pi| \ge 3|V'|^2 + 1$, then we can split $\pi$ into $\pi = p_1\cdot p_2 \cdot p_3$ where $p_1 = v_i\cdots v'$, $p_2 = v'\cdots v'$ and $v'$ appears $3|V'|+1$ times, $p_3 = v'\cdots v_o$.

\end{lemma}


\begin{proof}
Since we assume $|V'| \ge 2$, then $3|V'|^2 > |V'|^2+1$. By the pigeonhole principle, if the length of the path $|\pi| 
\ge 3|V'|^2 + 1 $ then there exists a $v'\in V'$ such that $v'$ appears at least $\lceil\dfrac{3|V'|^2 + 1}{|V'|}\rceil = 3|V'| + 1 $ times along the path. take the first and the last time $v'$ appears we got the desired path $p_2$. The construction of $p_1$ and $p_3$ is natural.
\end{proof}


We note that since there is a loop that repeats $3|V'| + 1$ times in the path. Since we assume that there is no positive cycle and we can omit 0-cycle, the minimum decrement of the path is at least $3|V'|$. And by this conclusion we have the following lemma.

\begin{lemma}
Given an $SCC = (V', E', \mu)$ where we assume $|V'| > 2, \mu(E')= \{1,-1\}$ and an inport $v_i\in V'$ and a outport $v_o \in V'$. Let $\pi = v_i\cdots v_o$ that $|\pi| \ge 3|V'|^2 + 1$ and contains no positive cycles, and by lemma 3 we can split $\pi$ into $\pi = p_1\cdot p_2 \cdot p_3$ where $p_1 = v_i\cdots v'$, $p_2 = v'\cdots v'$ and $p_3 = v'\cdots v_o$. Let $x,y_1,y_2$ and $z$ be the counter variable of vertices $v_i$, first $v'$, last $v'$ and $v_o$ respectively and let $y_1 = m$. If such $\pi$ exists, then we have $x\ge |V'|$.



\end{lemma}


\begin{proof}
Since there is no positive loop in the graph and we assume each edge increase or decrease the counter value by 1, path $p_1$ can at most increase the counter value by $|V'|$, i.e. $x - y_1 \le |V'|$. By the analysis above, we have $y_2 - x \le -3|V'|$. Consider the $p_3$ we have $z - y_2 \le |n|$. We can easily derive $z - x \le -2|V'|$ from the inequalities. Hence $x \ge z + 2|V'|$. Since, we require the counter value $z\ge 0$, we have $x \ge 2|V'| > |V'|$.




\end{proof}

With lemma 3 and lemma 4, we can derive a special path certificate in an  $SCC = (V', E', \mu)$ when the length of the path is larger than $3|V'|^2 + 1$.

\begin{lemma}
Given an $SCC = (V', E', \mu)$ and inport $v_i\in V'$ and outport $v_o\in V'$. If there is a path $\pi = v_i\cdots v_o$ in the SCC where $|\pi| \ge 3|V'|^2 + 1$, then there exists an path $\pi'$ and we can split $\pi'$ into $\pi = p_1\cdot p_2 \cdot p_3$ where $p_1 = v_i\cdots v'$, $p_2 = v'\cdots v'$ and $p_3 = v'\cdots v_o$ where each counter value on vertices of $\pi'$ is greater than 0.


\end{lemma}


\begin{proof}
A simply application to the path and results of lemma 3 and 4.
\end{proof}

\begin{algorithm}

	\caption{Situation 1 Formula Generation}
	\begin{algorithmic}
		
		
		\Function{Sit1Formula}{$WG,s,t$}
			\State \textbf{Input:} An one-counter automata $\mathcal{A}$ and starting config $(s,n)$ and ending config $(t,n')$.
			\State \textbf{Output:} A QFPA formula $\phi^1(G)$ that is satisfiable iff $t$ is reachable from $s$ in situation 1.
			\State $WG :=$ \Call{OneCounter2WG}{$\mathcal{A}$}
			\State $SWG :=$ \Call{WG2SWG}{$WG$}
			\State $ASWG :=$ \Call{SWG2ASWG}{$SWG$}
			\State $s_a := f_{SCC}(s)$ 
			\State $t_a := f_{SCC}(t)$ 
			\State $WG^{op} := $\Call{Op}{WG}
			\State $SWG^{op} := $\Call{Op}{SWG}
			\State $ASWG^{op} := $\Call{Op}{ASWG}
			\State $type3Lists :=$ \Call{FindType3}{$WG,s,t$}
			\ForEach{$[P_1^p, P_3^{(p,q)}, P_2^q]\in type3Lists$}
				\ForEach{$p_1\in P_1^p$}
					\ForEach{$p_3\in P_3^{(p,q)}$}
						\ForEach{$p_2^{op}\in P_2^q$}
							\State TODOs: 
							\State For each SCC on the absPath, guess the inport and outport.
							\State Guess the path in the SCC is a simple path or with cycles.
							\State Guess the all the maximum support of the path in the SCC and guarantee \State there is no positive cycles in it.
							\State If we guess the path is with cycles and length larger than $3|SCC.V|^2 + 1$ \State use path flow to generate the former half of the path and use DWT to deal \State with the latter half.
							\State Generate the formula and connecting it with the origin formula with \State conjunction.
						\EndFor
						
					\EndFor	
				\EndFor
			\EndFor
		\EndFunction
		
		
		\State\Function{Op}{$Graph$}
			\State \textbf{Input:} A WG or an SWG or an ASWG 
			\State \textbf{Output:} the skew transpose of the input graph.
			
		
		\EndFunction
		
		
	\end{algorithmic}
\end{algorithm}

As for the type-1 reachability certificate $\pi_1$ we need to consider more because type-1 certificate does not allow the existence of positive cycle in the support of the path flow.


For the sake of this requirement, we need to guess whether  the support of the path flow contains a cycle when the abstract path goes through an SCC. If the path in the SCC is only a simple path, we can guess the support and use DWT easily. 

Otherwise, there is a cycle in the support of the path flow. We use the algorithm computing $\sigma$ to test whether there is a positive cycle in the support of the flow. If not, we can make use of the lemma 5 and DWT to generate the formula. Due to the feature of DWT table, we only need to find all the positive simple cycles in the SCC and find all the possible support that destruct all the simple cycles.



\item \textbf{Situation 2:}
In this situation, we have no SCC tagged with negative cycle in the grpah. Hence, path only contains a type-2 certificate.

\item \textbf{Situation 3}
Similar to \textbf{Situation 2}, there is only a type-1 reachability certificate.

For \textbf{Situation 3}, we only need a algorithm to compute all the possible type-1 certificates and form them into a QFPA formula. This algorithm can also be used in \textbf{Situation 2} if we make use of the skew transpose of the graph.
Here is the algorithm.
\begin{algorithm}
	\caption{Situation 2 Formula Generation}
	\begin{algorithmic}
		\State \Function{Sit2Formula}{$WG,s,t$}
			\State \textbf{Input:} A weighted graph $WG$, starting vertex $s$ and ending vertex $t$.
			\State \textbf{Output:} A QFPA formula $\phi_2$ that is satisfiable iff there is a deasible path from $s$ to $t$.
			
			\State $SWG$ := \Call{WG2SWG}{$WG$}
			\State $ASWG$ := \Call{SWG2ASWG}{$SWG$}
			\State $P$ := \Call{DfsFindAbsPath}{$ASWG,s,t$}
			\ForEach{$\pi_1\in P$}
				\ForEach{\textit{SCC on $\pi_1$}}
					\If{$-\in $\Call{TestCycle}{SCC}}					
						\State TODO:
						\State Use path flow to construct the formula and wedge it.
					\Else
						\State TODO:
						\State Guess support $S$
						\State \Call{ComputeDWT}{$S,|S.V|$}
						\State Use DWT table to generate the formula and wedge it.
					\EndIf
				\EndFor
				
			\EndFor
		\EndFunction
		
		\State \Function{Sit1Formula}{$WG,s,t$}
			\State \textbf{Input:} A weighted graph $WG$, starting vertex $s$ and ending vertex $t$.
			\State \textbf{Output:} A QFPA formula $\phi_3$ that is satisfiable iff there is a deasible path from $s$ to $t$.
			\State $WG^{op}$ := \Call{Op}{$WG$}
			\State \Return \Call{Sit2Formula}{$WG^{op}$}
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\item \textbf{Situation 4:}
In this situation, we can omit all the 0-cycles because they do nothing "good" for the reachability problem. That means, there is no positve and negative cycle and 0-cycle does not change the counter value. Furthermore, it may introduce larger drop in the graph. Hence, this situation can be solve by simply guessing all the simple paths.

\end{itemize}
Finally, the whole process of the algorithm goes as follows:
\begin{enumerate}



\item Firstly convert the one-counter automata $\mathcal{A}$ into a weighted graph $WG$ and compute corresponding $SWG$ and $ASWG$. 

\item Then classify the $ASWG$ into the four situations and use the algorithms to generate target QFPA.
\end{enumerate}

\clearpage
\bibliography{ChistikovH17}
\bibliographystyle{plain}




\end{document}




















